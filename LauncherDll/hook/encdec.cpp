#include "stdafx.h"
#include "stdafx.h"
#include "encdec.h"
#include "aes.h"
#include <cstring>
// Adapter to the ported AES_TH from CryptoLib; keep include local and guarded
#include "../CryptoLib/AES_TH.h"

unsigned char init_key[16];
unsigned char encdec_key[32];
AES_KEY en_key, de_key;

unsigned char xor_table[256];

// AES_TH adapter state (disabled by default)
static bool s_useAesTh = false;
static unsigned char s_aesKey16[AES_KEY_SIZE] = {0};

void encdec_init()
{
	unsigned char key[256] = 
	{
		0x7E, 0x89, 0xDC, 0x78, 0x7F, 0x4B, 0xB6, 0x4F, 0x7D, 0x0D, 0x08, 0x16, 0x7C, 0xCF, 0x62, 0x21, 
		0x79, 0x80, 0x74, 0xA4, 0x78, 0x42, 0x1E, 0x93, 0x7A, 0x04, 0xA0, 0xCA, 0x7B, 0xC6, 0xCA, 0xFD, 
		0x6C, 0xBC, 0x2E, 0xB0, 0x6D, 0x7E, 0x44, 0x87, 0x6F, 0x38, 0xFA, 0xDE, 0x6E, 0xFA, 0x90, 0xE9, 
		0x6B, 0xB5, 0x86, 0x6C, 0x6A, 0x77, 0xEC, 0x5B, 0x68, 0x31, 0x52, 0x02, 0x69, 0xF3, 0x38, 0x35, 
		0x62, 0xAF, 0x7F, 0x08, 0x63, 0x6D, 0x15, 0x3F, 0x61, 0x2B, 0xAB, 0x66, 0x60, 0xE9, 0xC1, 0x51, 
		0x65, 0xA6, 0xD7, 0xD4, 0x64, 0x64, 0xBD, 0xE3, 0x66, 0x22, 0x03, 0xBA, 0x67, 0xE0, 0x69, 0x8D, 
		0x48, 0xD7, 0xCB, 0x20, 0x49, 0x15, 0xA1, 0x17, 0x4B, 0x53, 0x1F, 0x4E, 0x4A, 0x91, 0x75, 0x79, 
		0x4F, 0xDE, 0x63, 0xFC, 0x4E, 0x1C, 0x09, 0xCB, 0x4C, 0x5A, 0xB7, 0x92, 0x4D, 0x98, 0xDD, 0xA5, 
		0x46, 0xC4, 0x9A, 0x98, 0x47, 0x06, 0xF0, 0xAF, 0x45, 0x40, 0x4E, 0xF6, 0x44, 0x82, 0x24, 0xC1, 
		0x41, 0xCD, 0x32, 0x44, 0x40, 0x0F, 0x58, 0x73, 0x42, 0x49, 0xE6, 0x2A, 0x43, 0x8B, 0x8C, 0x1D, 
		0x54, 0xF1, 0x68, 0x50, 0x55, 0x33, 0x02, 0x67, 0x57, 0x75, 0xBC, 0x3E, 0x56, 0xB7, 0xD6, 0x09, 
		0x53, 0xF8, 0xC0, 0x8C, 0x52, 0x3A, 0xAA, 0xBB, 0x50, 0x7C, 0x14, 0xE2, 0x51, 0xBE, 0x7E, 0xD5, 
		0x5A, 0xE2, 0x39, 0xE8, 0x5B, 0x20, 0x53, 0xDF, 0x59, 0x66, 0xED, 0x86, 0x58, 0xA4, 0x87, 0xB1, 
		0x5D, 0xEB, 0x91, 0x34, 0x5C, 0x29, 0xFB, 0x03, 0x5E, 0x6F, 0x45, 0x5A, 0x5F, 0xAD, 0x2F, 0x6D, 
		0xE1, 0x35, 0x1B, 0x80, 0xE0, 0xF7, 0x71, 0xB7, 0xE2, 0xB1, 0xCF, 0xEE, 0xE3, 0x73, 0xA5, 0xD9, 
		0xE6, 0x3C, 0xB3, 0x5C, 0xE7, 0xFE, 0xD9, 0x6B, 0xE5, 0xB8, 0x67, 0x32, 0xE4, 0x7A, 0x0D, 0x05
	};

	GetPrivateProfileStringA("main", "encrypt_key", "", (char*)encdec_key, 32, "./LinGate.ini");
	memcpy(init_key, encdec_key, 16);
	for(int i = 0; i < 256; i++)
	{
		xor_table[i] = key[i] ^ encdec_key[i % 16];
	}
	AES_set_encrypt_key(encdec_key, 128, &en_key);
	AES_set_decrypt_key(encdec_key, 128, &de_key);
}

void encdec_init_key(unsigned char* encdec_key)
{
	unsigned char key[256] = 
	{
		0x7E, 0x89, 0xDC, 0x78, 0x7F, 0x4B, 0xB6, 0x4F, 0x7D, 0x0D, 0x08, 0x16, 0x7C, 0xCF, 0x62, 0x21, 
		0x79, 0x80, 0x74, 0xA4, 0x78, 0x42, 0x1E, 0x93, 0x7A, 0x04, 0xA0, 0xCA, 0x7B, 0xC6, 0xCA, 0xFD, 
		0x6C, 0xBC, 0x2E, 0xB0, 0x6D, 0x7E, 0x44, 0x87, 0x6F, 0x38, 0xFA, 0xDE, 0x6E, 0xFA, 0x90, 0xE9, 
		0x6B, 0xB5, 0x86, 0x6C, 0x6A, 0x77, 0xEC, 0x5B, 0x68, 0x31, 0x52, 0x02, 0x69, 0xF3, 0x38, 0x35, 
		0x62, 0xAF, 0x7F, 0x08, 0x63, 0x6D, 0x15, 0x3F, 0x61, 0x2B, 0xAB, 0x66, 0x60, 0xE9, 0xC1, 0x51, 
		0x65, 0xA6, 0xD7, 0xD4, 0x64, 0x64, 0xBD, 0xE3, 0x66, 0x22, 0x03, 0xBA, 0x67, 0xE0, 0x69, 0x8D, 
		0x48, 0xD7, 0xCB, 0x20, 0x49, 0x15, 0xA1, 0x17, 0x4B, 0x53, 0x1F, 0x4E, 0x4A, 0x91, 0x75, 0x79, 
		0x4F, 0xDE, 0x63, 0xFC, 0x4E, 0x1C, 0x09, 0xCB, 0x4C, 0x5A, 0xB7, 0x92, 0x4D, 0x98, 0xDD, 0xA5, 
		0x46, 0xC4, 0x9A, 0x98, 0x47, 0x06, 0xF0, 0xAF, 0x45, 0x40, 0x4E, 0xF6, 0x44, 0x82, 0x24, 0xC1, 
		0x41, 0xCD, 0x32, 0x44, 0x40, 0x0F, 0x58, 0x73, 0x42, 0x49, 0xE6, 0x2A, 0x43, 0x8B, 0x8C, 0x1D, 
		0x54, 0xF1, 0x68, 0x50, 0x55, 0x33, 0x02, 0x67, 0x57, 0x75, 0xBC, 0x3E, 0x56, 0xB7, 0xD6, 0x09, 
		0x53, 0xF8, 0xC0, 0x8C, 0x52, 0x3A, 0xAA, 0xBB, 0x50, 0x7C, 0x14, 0xE2, 0x51, 0xBE, 0x7E, 0xD5, 
		0x5A, 0xE2, 0x39, 0xE8, 0x5B, 0x20, 0x53, 0xDF, 0x59, 0x66, 0xED, 0x86, 0x58, 0xA4, 0x87, 0xB1, 
		0x5D, 0xEB, 0x91, 0x34, 0x5C, 0x29, 0xFB, 0x03, 0x5E, 0x6F, 0x45, 0x5A, 0x5F, 0xAD, 0x2F, 0x6D, 
		0xE1, 0x35, 0x1B, 0x80, 0xE0, 0xF7, 0x71, 0xB7, 0xE2, 0xB1, 0xCF, 0xEE, 0xE3, 0x73, 0xA5, 0xD9, 
		0xE6, 0x3C, 0xB3, 0x5C, 0xE7, 0xFE, 0xD9, 0x6B, 0xE5, 0xB8, 0x67, 0x32, 0xE4, 0x7A, 0x0D, 0x05
	};
	memcpy(init_key, encdec_key, 16);
	for(int i = 0; i < 256; i++)
	{
		xor_table[i] = key[i] ^ encdec_key[i % 16];
	}
	AES_set_encrypt_key(encdec_key, 128, &en_key);
	AES_set_decrypt_key(encdec_key, 128, &de_key);
}

void encdec_use_aes_th(bool enable)
{
	s_useAesTh = enable;
}

void encdec_set_key16(const unsigned char key16[16])
{
	if (!key16) return;
	std::memcpy(s_aesKey16, key16, AES_KEY_SIZE);
}

void encdec_encrypt(const unsigned char* src, unsigned char* dst, int len)
{
	// Optional AES_TH path: only safe for full 16-byte blocks to avoid partial block truncation.
	if (s_useAesTh && len >= AES_BLOCK_SIZE && (len % AES_BLOCK_SIZE) == 0)
	{
		// Copy, then apply the exact same order as AES_TH EncryptData does
		std::memcpy(dst, src, len);
		// AES_TH uses AdditionalEncrypt XOR step before AES block encryption
		AdditionalEncrypt(dst, static_cast<uint32_t>(len), s_aesKey16);
		EncryptData(dst, static_cast<uint32_t>(len), s_aesKey16);
		return;
	}

	// Default: legacy XOR scheme with 16-byte init_key
	for (int i = 0; i < len; i++)
	{
		//dst[i] = src[i] ^ xor_table[i % 256];
		dst[i] = src[i] ^ init_key[i % 16];
	}
	//if(len >= 16)
	//	AES_encrypt(dst, dst, &en_key);
}

void encdec_decrypt(const unsigned char* src, unsigned char* dst, int len)
{
	// Optional AES_TH path: only safe for full 16-byte blocks
	if (s_useAesTh && len >= AES_BLOCK_SIZE && (len % AES_BLOCK_SIZE) == 0)
	{
		std::memcpy(dst, src, len);
		// Reverse of EncryptData: AES decrypt then AdditionalEncrypt
		DecryptData(dst, static_cast<uint32_t>(len), s_aesKey16);
		return;
	}

	// Default: legacy XOR scheme with 16-byte init_key
	std::memcpy(dst, src, len);
	//if(len >= 16)
	//	AES_decrypt(dst, dst, &de_key);
	for (int i = 0; i < len; i++)
		//dst[i] ^= xor_table[i % 256];
		dst[i] ^= init_key[i % 16];
}
